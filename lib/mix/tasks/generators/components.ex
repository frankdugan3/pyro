defmodule Mix.Tasks.Pyro.Generators.Components do
  @moduledoc false

  import Pyro.ComponentLibrary.TemplateHelpers

  require EEx

  def generate(module, _opts \\ []) do
    path = Pyro.Info.component_output_path(module)

    if path do
      path = Path.relative_to_cwd(path)
      File.mkdir_p!(path)

      generated_file =
        Path.join(
          path,
          "#{module |> Module.split() |> List.last() |> Macro.underscore()}_components.ex"
        )

      code = gen_module(module)
      {formatter_fun, _formatter_opts} = Mix.Tasks.Format.formatter_for_file(generated_file)
      formatted_code = formatter_fun.(code)

      File.write!(generated_file, formatted_code)
    end
  end

  def render_attr(assigns) do
    EEx.eval_string(
      ~E'''
      attr <%= inspect @attr.name %>, <%= inspect @attr.type %><%=
        if @attr.default do %>, default: <%= inspect @attr.default %><% end %><%=
        if @attr.required do %>, required: true<% end %>
      ''',
      [assigns: assigns],
      trim: true
    )
  end

  def render_global(assigns) do
    EEx.eval_string(
      ~E'''
      attr <%= inspect @attr.name %>, :global<%=
        if @attr.default do %>, default: <%= inspect @attr.default %><%=
        if @attr.include do %>, include: <%= inspect @attr.include %><% end %><% end %>
      ''',
      [assigns: assigns],
      trim: true
    )
  end

  def render_module(assigns) do
    EEx.eval_string(
      ~E'''
      <% import Mix.Tasks.Pyro.Generators.Components %>
      defmodule <%= @module_name %> do
        # NOTE: THIS FILE WAS AUTOMATICALLY GENERATED BY PYRO. DO NOT EDIT DIRECTLY.
        # Instead, configure <%= @source_file %>

        use Phoenix.Component

        def __using__(_) do
          quote do
            import __MODULE__
          end
        end

        <%= for component <- @components do %>
      <%= if component.doc do %>@doc """
      <%= component.doc %>
      """
      @doc type: :component<% end %>
        <%= if !component.doc && !component.private? do %>@doc false<% end%>
        <%= for %Pyro.ComponentLibrary.Dsl.Prop{} = attr <- component.assigns do %><%= render_attr(attr: attr) %><% end %>
        <%= for %Pyro.ComponentLibrary.Dsl.Global{} = attr <- component.assigns do %><%= render_global(attr: attr) %><% end %>
        <%= for render <- component.render do %>def<%= if component.private? do %>p<% end %> <%= component.name %>(<%= Macro.to_string(render.args) %>) do
            <%= Macro.to_string(render.expr) %>
        end
        <% end %>
        <% end %>
      end
      ''',
      [assigns: assigns],
      trim: true
    )
  end

  def gen_module(module, opts \\ []) do
    embedded? = Keyword.get(opts, :embedded?, false)
    components = Pyro.Info.components(module)
    module_name = append_module_name(module, "Components")
    source_file = Path.relative_to_cwd(module.__info__(:compile)[:source])

    render_module(
      components: components,
      module_name: module_name,
      source_file: source_file,
      embedded?: embedded?
    )
  end

  def append_module_name(module, append) do
    module |> Module.split() |> Kernel.++([append]) |> Enum.join(".")
  end
end
